<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>16:9 å›¾ç‰‡å¹¿å‘Šæ°´å°å·¥å…·</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            background-color: #f0f2f5;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            margin: 0;
            min-height: 100vh;
        }

        h1 {
            color: #333;
            margin-bottom: 20px;
        }

        .container {
            background: white;
            padding: 30px;
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            width: 100%;
            max-width: 800px;
            text-align: center;
        }

        .upload-area {
            border: 2px dashed #ddd;
            border-radius: 8px;
            padding: 40px;
            cursor: pointer;
            transition: border-color 0.3s, background-color 0.3s;
            margin-bottom: 20px;
            position: relative;
        }

        .upload-area:hover {
            border-color: #1890ff;
            background-color: #f9f9f9;
        }

        .upload-area input[type="file"] {
            position: absolute;
            width: 100%;
            height: 100%;
            top: 0;
            left: 0;
            opacity: 0;
            cursor: pointer;
        }

        .upload-text {
            color: #666;
            font-size: 16px;
        }

        .upload-hint {
            color: #999;
            font-size: 12px;
            margin-top: 8px;
        }
        
        .image-controls {
            margin-bottom: 20px;
            padding: 15px;
            background: #e6f7ff;
            border: 1px solid #91d5ff;
            border-radius: 8px;
            display: none;
            text-align: left;
        }
        
        .image-controls.visible {
            display: block;
        }

        .btn-group {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-top: 20px;
        }

        .btn-secondary {
            background-color: #fff;
            color: #1890ff;
            border: 1px solid #1890ff;
        }

        .btn-secondary:hover {
            background-color: #e6f7ff;
        }

        #preview-container {
            margin-top: 20px;
            display: none;
            width: 100%;
        }

        canvas {
            max-width: 100%;
            height: auto;
            border-radius: 4px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            cursor: grab;
        }
        
        canvas:active {
            cursor: grabbing;
        }

        .btn {
            background-color: #1890ff;
            color: white;
            border: none;
            padding: 10px 24px;
            border-radius: 6px;
            font-size: 16px;
            cursor: pointer;
            transition: background-color 0.3s;
            margin-top: 20px;
            display: none;
            text-decoration: none;
            display: inline-block;
        }

        .btn:hover {
            background-color: #40a9ff;
        }

        .error-msg {
            color: #ff4d4f;
            margin-top: 10px;
            display: none;
            font-weight: 500;
        }

        .dev-options {
            margin-top: 20px;
            padding: 15px;
            background: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 8px;
            text-align: left;
            display: none; /* Initially hidden until image loaded, or always visible? Better hidden until needed */
        }
        
        .dev-options.visible {
            display: block;
        }

        .footer {
            margin-top: 30px;
            text-align: center;
            padding-bottom: 20px;
        }
        
        .footer a {
            color: #666;
            text-decoration: none;
            display: inline-flex;
            align-items: center;
            font-size: 14px;
            transition: color 0.3s;
        }
        
        .footer a:hover {
            color: #333;
        }

        .dev-options h3 {
            margin-top: 0;
            margin-bottom: 15px;
            font-size: 16px;
            color: #555;
            display: flex;
            align-items: center;
            justify-content: space-between;
            cursor: pointer;
        }
        
        .control-group {
            margin-bottom: 10px;
            display: flex;
            align-items: center;
        }
        
        .control-group label {
            width: 100px;
            font-size: 14px;
            color: #666;
        }
        
        .control-group input[type="range"] {
            flex: 1;
            margin: 0 10px;
        }
        
        .control-group input[type="number"] {
            width: 60px;
            padding: 4px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
    </style>
</head>
<body>

    <div class="container">
        <h1>BiliCover å¹¿å‘Šæ°´å°å·¥å…·</h1>
        
        <div class="upload-area" id="drop-zone">
            <input type="file" id="file-input" accept="image/png, image/jpeg, image/jpg">
            <div class="upload-text">ç‚¹å‡»æˆ–æ‹–æ‹½ä¸Šä¼ å›¾ç‰‡</div>
            <div class="upload-hint">æ”¯æŒä»»æ„æ¯”ä¾‹å›¾ç‰‡ï¼Œå¯è‡ªç”±ç¼©æ”¾å¹³ç§»</div>
        </div>

        <div id="error-msg" class="error-msg"></div>
        
        <div id="image-controls" class="image-controls">
            <div class="control-group">
                <label style="width: auto; margin-right: 15px; font-weight: bold;">ğŸ–±ï¸ å›¾ç‰‡æ“ä½œï¼š</label>
                <span style="font-size: 14px; color: #666; margin-right: 20px;">æ‹–æ‹½å¹³ç§»ï¼Œæ»šè½®ç¼©æ”¾</span>
            </div>
            <div class="control-group">
                <label>å›¾ç‰‡ç¼©æ”¾</label>
                <input type="range" id="img-scale-range" min="0.1" max="5.0" step="0.01" value="1.0">
                <input type="number" id="img-scale-num" min="0.1" max="5.0" step="0.01" value="1.0">
            </div>
            <div class="control-group">
                <button id="reset-img-btn" class="btn" style="display: inline-block; font-size: 14px; padding: 6px 12px; background: #666;">é‡ç½®å›¾ç‰‡ä½ç½®</button>
            </div>
        </div>

        <div id="dev-options" class="dev-options">
            <h3 id="dev-options-toggle">ğŸ›  å¼€å‘é€‰é¡¹ (ç‚¹å‡»æ”¶èµ·/å±•å¼€)</h3>
            <div id="dev-controls">
                <div class="control-group">
                    <label>ç¼©æ”¾æ¯”ä¾‹</label>
                    <input type="range" id="scale-range" min="0.5" max="5.0" step="0.1" value="3.9">
                    <input type="number" id="scale-num" min="0.5" max="5.0" step="0.1" value="3.9">
                </div>
                <div class="control-group">
                    <label>å³è¾¹è·</label>
                    <input type="range" id="margin-x-range" min="0" max="100" step="1" value="69">
                    <input type="number" id="margin-x-num" min="0" max="200" step="1" value="69">
                </div>
                <div class="control-group">
                    <label>ä¸‹è¾¹è·</label>
                    <input type="range" id="margin-y-range" min="0" max="100" step="1" value="65">
                    <input type="number" id="margin-y-num" min="0" max="200" step="1" value="65">
                </div>
                <div class="control-group">
                    <label>æ°´å°é€æ˜åº¦</label>
                    <input type="range" id="opacity-range" min="0.1" max="1.0" step="0.1" value="1.0">
                    <input type="number" id="opacity-num" min="0.1" max="1.0" step="0.1" value="1.0">
                </div>
                <hr style="border: 0; border-top: 1px solid #eee; margin: 15px 0;">
                <div class="control-group">
                    <label style="width: auto; margin-right: 10px;">å¯ç”¨å¯¹ç…§ç»„</label>
                    <input type="checkbox" id="ref-toggle">
                </div>
                <div class="control-group" id="main-opacity-group" style="display: none;">
                    <label>ä¸»å›¾é€æ˜åº¦</label>
                    <input type="range" id="main-opacity-range" min="0.0" max="1.0" step="0.1" value="1.0">
                    <input type="number" id="main-opacity-num" min="0.0" max="1.0" step="0.1" value="1.0">
                </div>
            </div>
        </div>

        <div id="preview-container">
            <canvas id="canvas"></canvas>
            <br>
            <div class="btn-group">
                <a id="download-raw-btn" class="btn btn-secondary hidden">ä¸‹è½½åŸå›¾ (16:9)</a>
                <a id="download-btn" class="btn hidden">ä¸‹è½½åŠ æ°´å°å›¾</a>
            </div>
        </div>
    </div>

    <div class="footer">
        <a href="https://github.com/afoim/bilicover_ad_add" target="_blank">
            <svg height="20" viewBox="0 0 16 16" version="1.1" width="20" aria-hidden="true" style="fill: currentColor; margin-right: 6px;">
                <path fill-rule="evenodd" d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z"></path>
            </svg>
            afoim/bilicover_ad_add
        </a>
    </div>

    <script>
        const fileInput = document.getElementById('file-input');
        const dropZone = document.getElementById('drop-zone');
        const errorMsg = document.getElementById('error-msg');
        const previewContainer = document.getElementById('preview-container');
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const downloadBtn = document.getElementById('download-btn');
        const downloadRawBtn = document.getElementById('download-raw-btn');
        
        // Image controls
        const imageControls = document.getElementById('image-controls');
        const imgScaleRange = document.getElementById('img-scale-range');
        const imgScaleNum = document.getElementById('img-scale-num');
        const resetImgBtn = document.getElementById('reset-img-btn');
        
        // Dev options controls
        const devOptions = document.getElementById('dev-options');
        const devOptionsToggle = document.getElementById('dev-options-toggle');
        const devControls = document.getElementById('dev-controls');
        
        const scaleRange = document.getElementById('scale-range');
        const scaleNum = document.getElementById('scale-num');
        const marginXRange = document.getElementById('margin-x-range');
        const marginXNum = document.getElementById('margin-x-num');
        const marginYRange = document.getElementById('margin-y-range');
        const marginYNum = document.getElementById('margin-y-num');
        const opacityRange = document.getElementById('opacity-range');
        const opacityNum = document.getElementById('opacity-num');
        
        const refToggle = document.getElementById('ref-toggle');
        const mainOpacityGroup = document.getElementById('main-opacity-group');
        const mainOpacityRange = document.getElementById('main-opacity-range');
        const mainOpacityNum = document.getElementById('main-opacity-num');

        // State
        let currentImg = null;
        let currentWatermark = null;
        let refImg = null;
        
        // Image transform state
        let imgState = {
            scale: 1,
            minScale: 1, // æ–°å¢ï¼šæœ€å°ç¼©æ”¾æ¯”ä¾‹
            x: 0,
            y: 0,
            isDragging: false,
            lastX: 0,
            lastY: 0
        };

        // Sync inputs
        function linkInputs(range, num, callback) {
            range.addEventListener('input', () => {
                num.value = range.value;
                if (callback) callback(parseFloat(range.value));
                else redraw();
            });
            num.addEventListener('input', () => {
                range.value = num.value;
                if (callback) callback(parseFloat(num.value));
                else redraw();
            });
        }
        
        // Link image scale inputs
        linkInputs(imgScaleRange, imgScaleNum, (val) => {
            imgState.scale = val;
            constrainImage(); // çº¦æŸ
            redraw();
        });
        
        resetImgBtn.addEventListener('click', () => {
            if (currentImg) {
                resetImageState(currentImg);
                redraw();
            }
        });

        linkInputs(scaleRange, scaleNum);
        linkInputs(marginXRange, marginXNum);
        linkInputs(marginYRange, marginYNum);
        linkInputs(opacityRange, opacityNum);
        linkInputs(mainOpacityRange, mainOpacityNum);
        
        // Canvas interaction
        canvas.addEventListener('mousedown', (e) => {
            if (!currentImg) return;
            imgState.isDragging = true;
            imgState.lastX = e.clientX;
            imgState.lastY = e.clientY;
        });
        
        window.addEventListener('mousemove', (e) => {
            if (!imgState.isDragging || !currentImg) return;
            const dx = e.clientX - imgState.lastX;
            const dy = e.clientY - imgState.lastY;
            
            // Convert screen pixels to canvas pixels
            // Canvas display size vs internal resolution
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            
            imgState.x += dx * scaleX;
            imgState.y += dy * scaleY;
            
            imgState.lastX = e.clientX;
            imgState.lastY = e.clientY;
            
            constrainImage(); // çº¦æŸç§»åŠ¨
            redraw();
        });
        
        window.addEventListener('mouseup', () => {
            imgState.isDragging = false;
        });
        
        canvas.addEventListener('wheel', (e) => {
            if (!currentImg) return;
            e.preventDefault();
            
            // ä»¥é¼ æ ‡ä¸ºä¸­å¿ƒçš„ç¼©æ”¾è®¡ç®—æ¯”è¾ƒå¤æ‚ï¼Œè¿™é‡Œå…ˆç®€åŒ–å¤„ç†ï¼š
            // å…ˆç¼©æ”¾ï¼Œç„¶åçº¦æŸä½ç½®ã€‚è¿™ä¹Ÿèƒ½ä¿è¯ä¸ç•™ç™½ã€‚
            
            const zoomSpeed = 0.05;
            const delta = e.deltaY > 0 ? -zoomSpeed : zoomSpeed;
            // é™åˆ¶æœ€å°ç¼©æ”¾ä¸º minScale
            const newScale = Math.max(imgState.minScale, Math.min(5.0, imgState.scale + delta));
            
            // ä¸ºäº†è®©ç¼©æ”¾ä½“éªŒæ›´å¥½ï¼ˆä¸ä»…ä»…æ˜¯å·¦ä¸Šè§’ç¼©æ”¾ï¼‰ï¼Œæˆ‘ä»¬å¯ä»¥å°è¯•ä¿æŒä¸­å¿ƒç‚¹
            // ä½†å¦‚æœç”¨æˆ·è¦æ±‚â€œå¿…é¡»è´´è¾¹â€ï¼Œç®€å•çš„ä¸­å¿ƒç¼©æ”¾å¯èƒ½ä¼šå¯¼è‡´è¶Šç•Œï¼Œ
            // éšåçš„ constrainImage ä¼šè‡ªåŠ¨ä¿®å¤è¶Šç•Œã€‚
            // ç®€å•çš„æ”¹è¿›ï¼šåŒæ—¶è°ƒæ•´ x, y ä»¥ä¿æŒç”»é¢ç›¸å¯¹ç¨³å®š
            // const ratio = newScale / imgState.scale;
            // imgState.x = imgState.x * ratio; // è¿™æ ·å†™æ˜¯ä¸å¯¹çš„ï¼Œéœ€è¦åŸºäºä¸­å¿ƒç‚¹
            
            // ç®€å•å®ç°ï¼šæ”¹å˜ scaleï¼Œç„¶å constrain
            imgState.scale = newScale;
            
            constrainImage(); // çº¦æŸ
            
            // æ›´æ–°æ§ä»¶
            imgScaleRange.value = imgState.scale.toFixed(2);
            imgScaleNum.value = imgState.scale.toFixed(2);
            
            redraw();
        }, { passive: false });
        
        // çº¦æŸå›¾ç‰‡ä½ç½®å’Œå¤§å°ï¼Œç¡®ä¿ä¸ç•™ç™½
        function constrainImage() {
            if (!currentImg) return;
            
            const width = 1920;
            const height = 1080;
            
            // 1. å†æ¬¡æ ¡éªŒæœ€å°æ¯”ä¾‹ (é˜²æ­¢è¾“å…¥æ¡†è¾“å…¥è¿‡å°æ•°å€¼)
            if (imgState.scale < imgState.minScale) {
                imgState.scale = imgState.minScale;
                imgScaleRange.value = imgState.scale.toFixed(2);
                imgScaleNum.value = imgState.scale.toFixed(2);
            }
            
            const dw = currentImg.width * imgState.scale;
            const dh = currentImg.height * imgState.scale;
            
            // 2. é™åˆ¶ä½ç½®
            // å›¾ç‰‡å³è¾¹ç¼˜ (x + dw) å¿…é¡» >= ç”»å¸ƒå³è¾¹ç¼˜ (width)  =>  x >= width - dw
            // å›¾ç‰‡å·¦è¾¹ç¼˜ (x) å¿…é¡» <= ç”»å¸ƒå·¦è¾¹ç¼˜ (0)          =>  x <= 0
            const minX = width - dw;
            const maxX = 0;
            
            const minY = height - dh;
            const maxY = 0;
            
            // å®¹é”™å¤„ç†ï¼šå¦‚æœè®¡ç®—ç²¾åº¦å¯¼è‡´ min > maxï¼ˆç†è®ºä¸Š scale >= minScale ä¸ä¼šå‘ç”Ÿï¼‰ï¼Œå– min
            if (minX > maxX) imgState.x = maxX; // åº”è¯¥ä¸ä¼šå‘ç”Ÿ
            else imgState.x = Math.max(minX, Math.min(imgState.x, maxX));
            
            if (minY > maxY) imgState.y = maxY;
            else imgState.y = Math.max(minY, Math.min(imgState.y, maxY));
        }

        refToggle.addEventListener('change', () => {
            if (refToggle.checked) {
                mainOpacityGroup.style.display = 'flex';
                if (!refImg) {
                    loadRefImage();
                } else {
                    redraw();
                }
            } else {
                mainOpacityGroup.style.display = 'none';
                redraw();
            }
        });

        devOptionsToggle.addEventListener('click', () => {
            if (devControls.style.display === 'none') {
                devControls.style.display = 'block';
            } else {
                devControls.style.display = 'none';
            }
        });

        function loadRefImage() {
            const img = new Image();
            img.onload = function() {
                refImg = img;
                redraw();
            };
            img.onerror = function() {
                alert('æ— æ³•åŠ è½½å¯¹ç…§å›¾ ad_than.pngï¼Œè¯·ç¡®ä¿æ–‡ä»¶å­˜åœ¨');
                refToggle.checked = false;
                mainOpacityGroup.style.display = 'none';
            };
            img.src = './ad_than.png';
        }

        // ç›‘å¬æ–‡ä»¶é€‰æ‹©
        fileInput.addEventListener('change', handleFileSelect);

        // æ‹–æ‹½æ”¯æŒ
        dropZone.addEventListener('dragover', (e) => {
            e.preventDefault();
            dropZone.style.borderColor = '#1890ff';
        });

        dropZone.addEventListener('dragleave', (e) => {
            e.preventDefault();
            dropZone.style.borderColor = '#ddd';
        });

        dropZone.addEventListener('drop', (e) => {
            e.preventDefault();
            dropZone.style.borderColor = '#ddd';
            const files = e.dataTransfer.files;
            if (files.length > 0) {
                fileInput.files = files;
                handleFile(files[0]);
            }
        });

        function handleFileSelect(e) {
            if (e.target.files.length > 0) {
                handleFile(e.target.files[0]);
            }
        }

        function handleFile(file) {
            // é‡ç½®çŠ¶æ€
            errorMsg.style.display = 'none';
            previewContainer.style.display = 'none';
            downloadBtn.classList.add('hidden');
            devOptions.classList.remove('visible'); // éšè—å¼€å‘é€‰é¡¹ç›´åˆ°åŠ è½½æˆåŠŸ

            if (!file.type.startsWith('image/')) {
                showError('è¯·ä¸Šä¼ å›¾ç‰‡æ–‡ä»¶');
                return;
            }

            const reader = new FileReader();
            reader.onload = function(e) {
                const img = new Image();
                img.onload = function() {
                    currentImg = img; // ä¿å­˜å›¾ç‰‡å¯¹è±¡
                    processImage(img);
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }

        function showError(msg) {
            errorMsg.textContent = msg;
            errorMsg.style.display = 'block';
        }

        function processImage(img) {
            // è®¾ç½® Canvas å°ºå¯¸ä¸º 1080p æ ‡å‡†
            canvas.width = 1920;
            canvas.height = 1080;
            
            // åˆå§‹åŒ–å›¾ç‰‡çŠ¶æ€ï¼šä½¿å…¶è¦†ç›–ç”»å¸ƒ
            resetImageState(img);
            
            // æ˜¾ç¤ºå›¾ç‰‡æ§åˆ¶
            imageControls.classList.add('visible');

            // å¦‚æœå·²ç»åŠ è½½è¿‡æ°´å°ï¼Œç›´æ¥é‡ç»˜
            if (currentWatermark) {
                redraw();
                devOptions.classList.add('visible');
                return;
            }

            // åŠ è½½æ°´å°å›¾ç‰‡
            const watermarkImg = new Image();
            watermarkImg.onload = function() {
                currentWatermark = watermarkImg; // ä¿å­˜æ°´å°å¯¹è±¡
                redraw();
                devOptions.classList.add('visible');
            };
            watermarkImg.onerror = function() {
                showError('æ— æ³•åŠ è½½æ°´å°å›¾ç‰‡ ad.pngï¼Œè¯·ç¡®ä¿æ–‡ä»¶å­˜åœ¨');
            };
            // ä½¿ç”¨ç›¸å¯¹è·¯å¾„åŠ è½½ï¼Œå‡è®¾ ad.png ä¸ index.html åœ¨åŒä¸€ç›®å½•
            watermarkImg.src = './ad.png';
        }
        
        function resetImageState(img) {
            // è®¡ç®— cover ç¼©æ”¾æ¯”ä¾‹
            const scaleX = canvas.width / img.width;
            const scaleY = canvas.height / img.height;
            const scale = Math.max(scaleX, scaleY);
            
            imgState.scale = scale;
            imgState.minScale = scale; // è®°å½•æœ€å°æ¯”ä¾‹
            
            // å±…ä¸­
            const scaledWidth = img.width * scale;
            const scaledHeight = img.height * scale;
            imgState.x = (canvas.width - scaledWidth) / 2;
            imgState.y = (canvas.height - scaledHeight) / 2;
            
            // æ›´æ–°æ§ä»¶
            imgScaleRange.min = scale.toFixed(2); // æ›´æ–°æ»‘å—æœ€å°å€¼
            imgScaleNum.min = scale.toFixed(2);
            
            imgScaleRange.value = scale.toFixed(2);
            imgScaleNum.value = scale.toFixed(2);
        }
        
        function redraw() {
            if (!currentImg) return; // å…è®¸åœ¨æ²¡æ°´å°æ—¶ç»˜åˆ¶ï¼ˆæ¯”å¦‚åˆšåŠ è½½å›¾ç‰‡ï¼‰
            
            // ç¡®ä¿ Canvas å°ºå¯¸æ­£ç¡®
            if (canvas.width !== 1920) {
                canvas.width = 1920;
                canvas.height = 1080;
            }
            
            const width = canvas.width;
            const height = canvas.height;

            // æ¸…ç©ºç”»å¸ƒ
            ctx.clearRect(0, 0, width, height);

            // 1. ç»˜åˆ¶å¯¹ç…§å›¾ï¼ˆå¦‚æœåœ¨åº•å±‚ä¸”å¯ç”¨ï¼‰
            if (refToggle.checked && refImg) {
                ctx.drawImage(refImg, 0, 0, width, height);
            }

            // 2. ç»˜åˆ¶ç”¨æˆ·ä¸»å›¾ (å¸¦å˜æ¢)
            // å¦‚æœå¼€å¯äº†å¯¹ç…§ç»„ï¼Œåº”ç”¨ä¸»å›¾é€æ˜åº¦ï¼›å¦åˆ™ä¸é€æ˜
            if (refToggle.checked) {
                const mainAlpha = parseFloat(mainOpacityNum.value);
                ctx.globalAlpha = isNaN(mainAlpha) ? 1.0 : mainAlpha;
            }
            
            // åº”ç”¨å›¾ç‰‡å˜æ¢
            // drawImage(image, dx, dy, dWidth, dHeight)
            const dw = currentImg.width * imgState.scale;
            const dh = currentImg.height * imgState.scale;
            ctx.drawImage(currentImg, imgState.x, imgState.y, dw, dh);
            
            ctx.globalAlpha = 1.0; // æ¢å¤
            
            // 3. ç»˜åˆ¶æ°´å° (å¦‚æœæœ‰)
            if (currentWatermark) {
                drawWatermark(currentWatermark, width, height);
            }
            
            // æ˜¾ç¤ºç»“æœ
            previewContainer.style.display = 'block';
            
            // è®¾ç½®ä¸‹è½½æŒ‰é’®é€»è¾‘
            setupDownloadButtons(width, height);
        }
        
        function setupDownloadButtons(width, height) {
            // ä¸‹è½½åŸå§‹è£å‰ªå›¾ (16:9)
            downloadRawBtn.onclick = function() {
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = width;
                tempCanvas.height = height;
                const tempCtx = tempCanvas.getContext('2d');
                
                // ç»˜åˆ¶ä¸»å›¾ (åº”ç”¨å½“å‰çš„å˜æ¢ï¼Œä½†ä¸å¸¦é€æ˜åº¦å’Œå¯¹ç…§ç»„)
                const dw = currentImg.width * imgState.scale;
                const dh = currentImg.height * imgState.scale;
                tempCtx.drawImage(currentImg, imgState.x, imgState.y, dw, dh);
                
                downloadLink(tempCanvas, 'processed_image_raw.png');
                return false;
            };
            downloadRawBtn.classList.remove('hidden');
            
            // ä¸‹è½½åŠ æ°´å°å›¾
            downloadBtn.onclick = function() {
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = width;
                tempCanvas.height = height;
                const tempCtx = tempCanvas.getContext('2d');
                
                // 1. ç»˜åˆ¶ä¸»å›¾
                const dw = currentImg.width * imgState.scale;
                const dh = currentImg.height * imgState.scale;
                tempCtx.drawImage(currentImg, imgState.x, imgState.y, dw, dh);
                
                // 2. ç»˜åˆ¶æ°´å°
                if (currentWatermark) {
                    drawWatermarkOnContext(tempCtx, currentWatermark, width, height);
                }
                
                downloadLink(tempCanvas, 'processed_image_ad.png');
                return false;
            };
            downloadBtn.classList.remove('hidden');
        }
        
        function downloadLink(canvasSource, filename) {
            const dataURL = canvasSource.toDataURL('image/png');
            const link = document.createElement('a');
            link.download = filename;
            link.href = dataURL;
            link.click();
        }

        function drawWatermark(watermarkImg, canvasWidth, canvasHeight) {
            drawWatermarkOnContext(ctx, watermarkImg, canvasWidth, canvasHeight);
        }

        function drawWatermarkOnContext(context, watermarkImg, canvasWidth, canvasHeight) {
            // è·å–å‚æ•°
            const scaleUser = parseFloat(scaleNum.value) || 3.9;
            const marginXUser = parseFloat(marginXNum.value) || 69;
            const marginYUser = parseFloat(marginYNum.value) || 65;
            const opacityUser = parseFloat(opacityNum.value) || 1.0;

            // æ°´å°å‚æ•°è®¡ç®—
            const scaleFactor = canvasHeight / 1080;
            const wmRatio = watermarkImg.width / watermarkImg.height;
            
            // ç›®æ ‡é«˜åº¦ï¼šæ ¹æ® 1080p ä¸‹çº¦ 60px çš„é«˜åº¦è¿›è¡Œç¼©æ”¾ï¼Œå†ä¹˜ä»¥ç”¨æˆ·è®¾å®šçš„æ¯”ä¾‹
            const targetHeight = 60 * scaleFactor * scaleUser;
            const targetWidth = targetHeight * wmRatio;

            // è¾¹è·ä¹Ÿéœ€è¦æ ¹æ®åˆ†è¾¨ç‡ç¼©æ”¾
            const marginRight = marginXUser * scaleFactor;
            const marginBottom = marginYUser * scaleFactor;

            // è®¡ç®—ä½ç½® (å³ä¸‹è§’)
            const x = canvasWidth - targetWidth - marginRight;
            const y = canvasHeight - targetHeight - marginBottom;

            // ç»˜åˆ¶æ°´å°å›¾ç‰‡
            context.globalAlpha = opacityUser;
            context.drawImage(watermarkImg, x, y, targetWidth, targetHeight);
            context.globalAlpha = 1.0; // æ¢å¤é€æ˜åº¦
        }
    </script>
</body>
</html>
